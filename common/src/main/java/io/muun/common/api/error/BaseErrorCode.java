package io.muun.common.api.error;

import io.muun.common.utils.Pair;
import io.muun.common.utils.Preconditions;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Range;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;
import javax.annotation.Nullable;

/**
 * Muun HTTP errors are serialized as a json-encoded {@link Error}, and automatically deserialized
 * as an {@link io.muun.common.exception.HttpException}. These errors have globally unique error
 * codes used to identify and handle different failure scenarios.
 *
 * <p>If you want to register new error codes, you must create an enum class implementing
 * {@link BaseErrorCode}, like so:
 * <pre>{@code
 *     @Getter
 *     @AllArgsConstructor
 *     enum Error implements BaseErrorCode {
 *
 *         NOT_ENOUGH(Code.NOT_ENOUGH, StatusCode.SERVER_FAILURE, "Not enough funds"),
 *         NOT_FOUND(Code.NOT_FOUND, StatusCode.CLIENT_FAILURE, "No matches");
 *
 *         static class Code {
 *             public static final int NOT_ENOUGH = 100;
 *             public static final int NOT_FOUND = 101;
 *         }
 *
 *         static {
 *             BaseErrorCode.registerErrorCodes(Range.closedOpen(100, 200));
 *         }
 *
 *         private final int code;
 *         private final StatusCode status;
 *         private final String description;
 *     }
 * }</pre>
 *
 * <p>The error code constants in the inner class {@code Code} are useful in case we want to use
 * them in a client's method annotation, since only compile-time constants are accepted there:
 * <pre>{@code
 *     @POST("/fund")
 *     @Retry(doNotRetryOn = { Error.Code.NOT_ENOUGH })
 *     Completable fund(@Body RequestJson request);
 * }</pre>
 */
public interface BaseErrorCode {

    @VisibleForTesting
    InternalState _STATE = new InternalState();

    int getCode();

    StatusCode getStatus();

    String getDescription();

    // This method will be automatically generated by enums, no need to implement it manually
    String name();

    /**
     * Register error codes from an enum implementing {@link BaseErrorCode}, making it automatically
     * serializable/deserializable when included in an {@link Error}. You also have to declare the
     * ranges of error code numbers that are reserved for this enum class.
     *
     * <p>Should be called within the static initializer block of all enums implementing
     * {@link BaseErrorCode}.
     *
     * @param reservedErrorCodeRanges the ranges of error code numbers reserved for this enum class.
     */
    @SafeVarargs
    @SuppressWarnings("unchecked")
    static void registerErrorCodes(Range<Integer>... reservedErrorCodeRanges) {

        // assume we are being called from within the error code class, and extract the caller class
        final String callerClassName = new Throwable().getStackTrace()[1].getClassName();
        final Class<? extends BaseErrorCode> errorCodeClass;
        try {
            errorCodeClass = (Class<? extends BaseErrorCode>) Class.forName(callerClassName);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }

        Preconditions.checkArgument(
                BaseErrorCode.class.isAssignableFrom(errorCodeClass),
                "Caller should be an error code class implementing BaseErrorCode"
        );

        registerErrorCodes(errorCodeClass, reservedErrorCodeRanges);
    }

    /**
     * Register error codes from an enum implementing {@link BaseErrorCode}, making it automatically
     * serializable/deserializable when included in an {@link Error}. You also have to declare the
     * ranges of error code numbers that are reserved for this enum class.
     *
     * @param errorCodeClass an enum class implementing {@link BaseErrorCode}.
     * @param reservedErrorCodeRanges the ranges of error code numbers reserved for this enum class.
     */
    @SafeVarargs
    static void registerErrorCodes(
            Class<? extends BaseErrorCode> errorCodeClass,
            Range<Integer>... reservedErrorCodeRanges) {

        Preconditions.checkArgument(errorCodeClass.isEnum(), "Error code class should be an enum");

        // track reserved error code ranges, making sure they haven't been reserved by any other
        // error code classes
        synchronized (_STATE) {

            for (Range<Integer> range : reservedErrorCodeRanges) {

                final Pair<Range<Integer>, Class<?>> intersection =
                        _STATE.reservedErrorCodeRanges.getFirstIntersectionWith(range);

                if (intersection != null) {
                    throw new IllegalArgumentException(String.format(
                            "Error codes in range [%d, %d] are reserved by both classes:\n"
                                    + "* %s\n"
                                    + "* %s",
                            intersection.fst.lowerEndpoint(),
                            intersection.fst.upperEndpoint(),
                            intersection.snd.getCanonicalName(),
                            errorCodeClass.getCanonicalName()
                    ));
                }

                _STATE.reservedErrorCodeRanges.add(range, errorCodeClass);
            }
        }

        // track error codes, making sure they are unique and fall within the reserved error code
        // ranges
        for (BaseErrorCode errorCode : errorCodeClass.getEnumConstants()) {

            final Class<?> classOwningCodeRange =
                    _STATE.reservedErrorCodeRanges.getClassAt(errorCode.getCode());

            if (!errorCodeClass.equals(classOwningCodeRange)) {
                throw new IllegalArgumentException(String.format(
                        "Using error code %d outside of reserved error code ranges for class %s",
                        errorCode.getCode(),
                        errorCodeClass.getCanonicalName()
                ));
            }

            final BaseErrorCode previousCode =
                    _STATE.errorCodeMap.put(errorCode.getCode(), errorCode);

            if (previousCode != null) {
                throw new IllegalArgumentException(String.format(
                        "Error code %d is used twice in class %s",
                        errorCode.getCode(),
                        errorCodeClass.getCanonicalName()
                ));
            }
        }

        // if there's any inner class defined within the error code class, make sure it's a
        // "static class Code" that defines constants for the numeric error codes that match both
        // the number and names of the corresponding enum values in the outer class
        for (Class<?> innerClass : errorCodeClass.getDeclaredClasses()) {

            final boolean innerClassIsStatic = Modifier.isStatic(innerClass.getModifiers());
            final boolean innerClassIsNamedCode = innerClass.getSimpleName().equals("Code");

            if (!innerClassIsStatic || !innerClassIsNamedCode) {
                throw new IllegalArgumentException(String.format(
                        "%s may only have a single inner class that's static and named 'Code'",
                        errorCodeClass.getCanonicalName()
                ));
            }

            for (Field field : innerClass.getFields()) {

                final boolean fieldIsStatic = Modifier.isStatic(field.getModifiers());
                final boolean fieldIsFinal = Modifier.isFinal(field.getModifiers());
                final boolean fieldIsInt = field.getType() == int.class;

                if (!fieldIsStatic || !fieldIsFinal || !fieldIsInt) {
                    throw new IllegalArgumentException(String.format(
                            "%s may only have static final int fields",
                            innerClass.getCanonicalName()
                    ));
                }

                try {

                    final String constantName = field.getName();
                    final int constantValue = field.getInt(null);

                    final BaseErrorCode errorCode = _STATE.errorCodeMap.get(constantValue);

                    if (errorCode == null || !errorCode.getClass().equals(errorCodeClass)) {
                        throw new IllegalArgumentException(String.format(
                                "Code %d (named %s) doesn't match any error code defined in %s",
                                constantValue,
                                constantName,
                                errorCodeClass.getCanonicalName()
                        ));
                    }

                    if (!errorCode.name().equals(constantName)) {
                        throw new IllegalArgumentException(String.format(
                                "Code %s should have the same name as error code %s defined in %s",
                                constantName,
                                errorCode.name(),
                                errorCodeClass.getCanonicalName()
                        ));
                    }

                } catch (IllegalAccessException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }

    /**
     * Serialize from json compatible value.
     */
    @JsonCreator
    static BaseErrorCode fromValue(int value) {

        if (!_STATE.errorCodeMap.containsKey(value)) {
            throw new IllegalArgumentException("Invalid error code: " + value);
        }

        return _STATE.errorCodeMap.get(value);
    }

    /**
     * Serialize to json compatible value.
     */
    @JsonValue
    default int toValue() {

        return getCode();
    }

    @VisibleForTesting
    class InternalState {

        private final Map<Integer, BaseErrorCode> errorCodeMap;

        private final DisjointRangeToClassMap reservedErrorCodeRanges;

        private InternalState() {

            errorCodeMap = new HashMap<>();
            reservedErrorCodeRanges = new DisjointRangeToClassMap();
        }

        public TestSession startTest() {

            final Map<Integer, BaseErrorCode> errorCodeMapCopy = new HashMap<>(errorCodeMap);
            errorCodeMap.clear();

            final Map<Range<Integer>, Class<?>> rangeToClassMapCopy = new HashMap<>(
                    reservedErrorCodeRanges.rangeToClassMap
            );
            reservedErrorCodeRanges.rangeToClassMap.clear();

            return () -> {
                errorCodeMap.clear();
                errorCodeMap.putAll(errorCodeMapCopy);

                reservedErrorCodeRanges.rangeToClassMap.clear();
                reservedErrorCodeRanges.rangeToClassMap.putAll(rangeToClassMapCopy);
            };
        }

        public interface TestSession extends java.io.Closeable {

            void close();
        }
    }

    /**
     * Maintain a map from integer ranges (of error codes) to classes (reserving those ranges). All
     * ranges are disjoint, so any given integer code may be reserved by up to one class.
     */
    @VisibleForTesting
    class DisjointRangeToClassMap {

        // disjoint ranges are ordered by the range's starting endpoint
        private final TreeMap<Range<Integer>, Class<?>> rangeToClassMap = new TreeMap<>(
                (left, right) -> {

                    final Integer lowerLeft = left.hasLowerBound()
                            ? left.lowerEndpoint()
                            : Integer.MIN_VALUE;

                    final Integer lowerRight = right.hasLowerBound()
                            ? right.lowerEndpoint()
                            : Integer.MIN_VALUE;

                    return lowerLeft.compareTo(lowerRight);
                }
        );

        public void add(Range<Integer> range, Class<?> klass) {

            rangeToClassMap.put(range, klass);
        }

        @Nullable
        public Class<?> getClassAt(int value) {

            // since ranges are ordered by their starting endpoint, the range containing a certain
            // integer value must be the range starting at that value, or the range starting at the
            // greatest value that is less than the specified value (a.k.a. the floor function)

            final Map.Entry<Range<Integer>, Class<?>> floor =
                    rangeToClassMap.floorEntry(Range.singleton(value));

            if (floor != null && floor.getKey().contains(value)) {
                return floor.getValue();
            }

            return null;
        }

        @Nullable
        public Pair<Range<Integer>, Class<?>> getFirstIntersectionWith(Range<Integer> range) {

            // since ranges are ordered by their starting endpoint, the ranges intersecting a
            // certain range are:
            // 1. the range starting at or right before the range's starting endpoint (floor)
            // 2. the range starting at or right after the range's starting endpoint (ceiling)
            // 3. a range starting after the previous range (may only exist if 2 also exists)

            // if present, return 1 (a.k.a. the floor function)
            final Map.Entry<Range<Integer>, Class<?>> floor = rangeToClassMap.floorEntry(range);

            if (floor != null && floor.getKey().isConnected(range)) {
                // touching but non-intersecting ranges are considered "connected", so we need to
                // check that the intersection is non-empty
                final Range<Integer> intersection = floor.getKey().intersection(range);
                if (!intersection.isEmpty()) {
                    return Pair.of(intersection, floor.getValue());
                }
            }

            // else, if present, return 2 (a.k.a. the ceiling function)
            final Map.Entry<Range<Integer>, Class<?>> ceiling = rangeToClassMap.ceilingEntry(range);

            if (ceiling != null && ceiling.getKey().isConnected(range)) {
                // touching but non-intersecting ranges are considered "connected", so we need to
                // check that the intersection is non-empty
                final Range<Integer> intersection = ceiling.getKey().intersection(range);
                if (!intersection.isEmpty()) {
                    return Pair.of(intersection, ceiling.getValue());
                }
            }

            // else, there's no intersection
            return null;
        }
    }
}
