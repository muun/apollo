package libwallet

import (
	"crypto/aes"
	"crypto/rand"
	"fmt"

	"github.com/btcsuite/btcd/btcec/v2"
	"github.com/muun/libwallet/aescbc"
	"github.com/muun/libwallet/encryption"
)

const serializedPublicKeyLength = btcec.PubKeyBytesLenCompressed

type Encrypter interface {
	// Encrypt the payload and return a string with the necesary information for decryption
	Encrypt(payload []byte) (string, error)
}

type Decrypter interface {
	// Decrypt a payload generated by Encrypter
	Decrypt(payload string) ([]byte, error)
}

// Assert hdPubKeyEncrypter fulfills Encrypter interface
var _ Encrypter = (*encryption.HdPubKeyEncrypter)(nil)

// Assert hdPrivKeyDecrypter fulfills Decrypter interface
var _ Decrypter = (*encryption.HdPrivKeyDecrypter)(nil)

// encryptWithPubKey encrypts a message using a pubKey
// It uses ECDHE/AES/CBC leaving padding up to the caller.
func encryptWithPubKey(pubKey *btcec.PublicKey, plaintext []byte) (*btcec.PublicKey, []byte, error) {
	// Use deprecated ECDH for compat
	pubEph, sharedSecret, err := encryption.GenerateSharedEncryptionSecret(pubKey)
	if err != nil {
		return nil, nil, err
	}
	serializedPubkey := pubEph.SerializeCompressed()
	iv := serializedPubkey[len(serializedPubkey)-aes.BlockSize:]

	ciphertext, err := aescbc.EncryptNoPadding(sharedSecret, iv, plaintext)
	if err != nil {
		return nil, nil, fmt.Errorf("encryptWithPubKey: encrypt failed: %w", err)
	}

	return pubEph, ciphertext, nil
}

// decryptWithPrivKey decrypts a message encrypted to a pubKey using the corresponding privKey
// It uses ECDHE/AES/CBC leaving padding up to the caller.
func decryptWithPrivKey(privKey *btcec.PrivateKey, rawPubEph []byte, ciphertext []byte) ([]byte, error) {
	// Use deprecated ECDH for compat
	sharedSecret, err := encryption.RecoverSharedEncryptionSecret(privKey, rawPubEph)
	if err != nil {
		return nil, err
	}

	iv := rawPubEph[len(rawPubEph)-aes.BlockSize:]

	plaintext, err := aescbc.DecryptNoPadding(sharedSecret, iv, ciphertext)
	if err != nil {
		return nil, fmt.Errorf("decryptWithPrivKey: failed to decrypt: %w", err)
	}

	return plaintext, nil
}

func randomBytes(count int) []byte {
	buf := make([]byte, count)
	_, err := rand.Read(buf)
	if err != nil {
		panic("couldn't read random bytes")
	}

	return buf
}

// What follows are workarounds for https://github.com/golang/go/issues/46893

type DecryptOperation struct {
	d       Decrypter
	payload string
}

func NewDecryptOperation(key *HDPrivateKey, payload string) *DecryptOperation {
	return &DecryptOperation{key.Decrypter(), payload}
}
func NewDecryptOperationFrom(sender *PublicKey, key *HDPrivateKey, payload string) *DecryptOperation {
	return &DecryptOperation{key.DecrypterFrom(sender), payload}
}

func (o *DecryptOperation) Decrypt() ([]byte, error) {
	return o.d.Decrypt(o.payload)
}

type EncryptOperation struct {
	e       Encrypter
	payload []byte
}

func NewEncryptOperation(key *HDPrivateKey, payload []byte) *EncryptOperation {
	return &EncryptOperation{key.Encrypter(), append([]byte{}, payload...)}
}

func (o *EncryptOperation) Encrypt() (string, error) {
	return o.e.Encrypt(o.payload)
}
